# Copyright 2011 Gridcentric Inc.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

import json
import uuid

from nova import db
from nova import quota
from nova import policy
from nova.compute import flavors
from nova.compute import vm_states
from nova.compute import power_state
from nova.network import model as network_model
from nova.virt.fake import FakeInstance

from cobalt.nova import api
from cobalt.nova import image

class TestInducedException(Exception):

    def __init__(self, *args, **kwargs):
        super(TestInducedException, self).__init__(*args, **kwargs)
    pass

class MockImageService(object):
    """
    A simple mock for the Nova ImageService defined
    """
    def __init__(self):
        self.images = {}
        self.image_data = {}

    def show(self, context, image_id):
        return self.images.get(image_id, {})

    def create(self, context, sent_data):
        image_id = create_uuid()
        self.images[image_id] = sent_data

    def update(self, context, image_id, metadata, image_file):
        self.images[image_id] = metadata
        image_data = [line for line in image_file.readlines()]
        self.image_data[image_id] = image_data


    def download(self, context, image_id, image_file):
        image_data = self.image_data.get(image_id, [])
        image_file.writelines(image_data)

    def delete(self, context, image_id):
        if image_id in self.images:
            del self.images[image_id]

def mock_image_service():
    return image.ImageService(image_service=MockImageService())


def do_nothing(*args, **kwargs):
    pass

def mock_policy():
    policy.enforce = do_nothing

def mock_quota():
    api.API._check_quota = do_nothing

stored_hints = {}

class BDMSchedulerException(Exception):
    pass

def mock_scheduler_rpcapi(scheduler_rpcapi, hosts=None):
    if hosts == None:
        hosts = [create_uuid()]

    def mock_select_destinations(context, request_spec, filter_properties):
        force_host = filter_properties.get('force_hosts', None)

        # Enforce BDM properties in request spec
        bdm = request_spec['block_device_mapping']
        if type(bdm) != list:
            raise BDMSchedulerException("BDM should be list of dicts")
        for d in bdm:
            if type(d) != dict:
                raise BDMSchedulerException("BDM should be list of dicts")
                for key in [ 'device_name', 'delete_on_termination',
                             'virtual_name', 'snapshot_id', 'volume_id',
                             'volume_size', 'no_device', 'connection_info']:
                    if not d.has_key(key):
                        raise BDMSchedulerException(
                                "BDM entry %s incomplete" % str(d))
        # We only pass data in a specific test
        if len(bdm) > 1:
            if len(bdm) != 2:
                raise BDMSchedulerException("Unexpected BDM %s" % str(bdm))
            bdev = bdm[1]
            try:
                import uuid #WHY?!?!
                uuid.UUID(bdev['volume_id'])
            except ValueError:
                raise BDMSchedulerException("Invalid instance UUID %s in "
                            "block device spec." % str(bdev['volume_id']))
            if not bdev['delete_on_termination']:
                raise BDMSchedulerException("Unexpected delete on term "
                            "in block device spec.")
            if bdev['device_name'] != 'vbd':
                raise BDMSchedulerException("Unexpected device name %s "
                            "in block device spec." % bdev['device_name'])

        az = request_spec['instance_properties']['availability_zone']
        if az is not None:
            # Overload for the sake of testing
            filter_properties['availability_zone'] = az
        if len(filter_properties['scheduler_hints'].keys()) > 0:
            for uuid in request_spec['instance_uuids']:
                instance_hints = stored_hints.get(uuid, [])
                instance_hints.append(filter_properties)
                stored_hints[uuid] = instance_hints
        if force_host is not None:
            return [dict(host=force_host[0], nodename=force_host[0],
                    limits=None)] * len(request_spec['instance_uuids'])
        host_list = [hosts[i % len(hosts)]
                     for i in range(0, len(request_spec['instance_uuids']))]
        return [dict(host=host, nodename=host, limits=None)
                for host in host_list]

    scheduler_rpcapi.select_destinations = mock_select_destinations

class MockVmsConn(object):
    """
    A simple mock vms connection class that allows us to test functionality without relying on 
    actually communicating with the vms libraries. Essentially used to isolate parts of the system.
    """
    def __init__(self):
        self.return_vals = {}
        self.params_passed = []

    def set_return_val(self, method, value):
        values = self.return_vals.get(method, [])
        values.append(value)
        self.return_vals[method] = values

    def pop_return_value(self, method):
        values = self.return_vals.get(method, None)
        if values == [] or values == None:
            raise Exception("A call to method '%s' was unexpected." % method)
        val = values.pop()
        if isinstance(val, Exception):
            raise val
        return val

    def configure(self):
        pass

    def bless(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("bless")

    def post_bless(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("post_bless")

    def bless_cleanup(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("bless_cleanup")

    def discard(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("discard")

    def launch(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("launch")

    def replug(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("replug")

    def pre_migration(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("pre_migration")

    def post_migration(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("post_migration")

    def get_hypervisor_hostname(self):
        return "MockHypervisor"

    def get_instance_info(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("get_instance_info")

    def pause_instance(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("pause_instance")

    def unpause_instance(self, *args, **kwargs):
        self.params_passed.append({'args': args, 'kwargs': kwargs})
        return self.pop_return_value("unpause_instance")

def create_uuid():
    return str(uuid.uuid4())

def create_security_group(context, values):
    values = values.copy()
    values['user_id'] = context.user_id
    values['project_id'] = context.project_id
    return db.security_group_create(context, values)

def add_block_dev(context, instance_uuid, device_id):
    bdev = {
                'instance_uuid' : instance_uuid,
                'volume_id'     : create_uuid(),
                'device_name'   : device_id,
                'delete_on_termination' : True,
                'volume_size'   : ''
            }
    db.block_device_mapping_create(context, bdev)

def create_flavor(flavor=None):
    if flavor == None:
        flavor = {}

    return flavors.create(flavor.get('name', create_uuid()),
                                 flavor.get('memory', 512),
                                 flavor.get('vcpus', 1),
                                 flavor.get('root_gb',0),
                                 flavor.get('ephemeral_gb',0),
                                 flavor.get('flavorid', None),
                                 flavor.get('swap', 0),
                                 flavor.get('rxtx_factor',1))

def create_instance(context, instance=None, driver=None):
    """Create a test instance"""

    if instance == None:
        instance = {}

    system_metadata = instance.get('system_metadata', {})
    if 'instance_type_id' in instance:
        instance_type = flavors.get_flavor(
                instance['instance_type_id'])
    else:
        instance_type = flavors.get_flavor_by_name('m1.tiny')
    system_metadata.update(flavors.save_flavor_info(dict(), instance_type))

    instance.setdefault('user_id', context.user_id)
    instance.setdefault('project_id', context.project_id)
    instance.setdefault('instance_type_id', instance_type['id'])
    instance.setdefault('system_metadata', system_metadata)
    instance.setdefault('image_id', 1)
    instance.setdefault('image_ref', 1)
    instance.setdefault('reservation_id', 'r-fakeres')
    instance.setdefault('launch_time', '10')
    instance.setdefault('mac_address', "ca:ca:ca:01")
    instance.setdefault('ami_launch_index', 0)
    instance.setdefault('vm_state', vm_states.ACTIVE)
    instance.setdefault('root_gb', 10)
    instance.setdefault('ephemeral_gb', 10)
    instance.setdefault('memory_mb', 512)
    instance.setdefault('vcpus', 1)
    instance.setdefault('info_cache', {'network_info':json.dumps({})})

        # We should record in the quotas information about this instance.
    reservations = quota.QUOTAS.reserve(context, instances=1,
                         ram=instance['memory_mb'],
                         cores=instance['vcpus'])

    context.elevated()
    instance_ref = db.instance_create(context, instance)
    db.block_device_mapping_create(context,
            {'source_type': 'image',
             'destination_type': 'local',
             'device_type': 'disk',
             'image_id': 1,
             'boot_index': 0,
             'instance_uuid': instance_ref['uuid']},
             legacy=False)

    if driver:
        # Add this instance to the driver
        driver.instances[instance_ref.name] = FakeInstance(instance_ref.name,
                                                           instance_ref.get('power_state',
                                                                             power_state.RUNNING))

    quota.QUOTAS.commit(context, reservations)

    return instance_ref['uuid']

def create_pre_blessed_instance(context, instance=None, source_uuid=None):
    """
    Creates a blessed instance in the state that the API would leave it. In other words an instance
    that is ready to be blessed by the manager.
    """
    if source_uuid == None:
        source_uuid = create_instance(context)
    if instance == None:
        instance = {}

    instance['disable_terminate'] = True

    for key in ['metadata', 'system_metadata']:
        d = instance.get(key, {})
        d['blessed_from'] = source_uuid
        instance[key] = d

    return create_instance(context, instance)

def create_blessed_instance(context, instance=None, source_uuid=None):
    if source_uuid == None:
        source_uuid = create_instance(context)
    if instance == None:
        instance = {}

    instance['disable_terminate'] = True
    instance['vm_state'] = 'blessed'
    for key in ['metadata', 'system_metadata']:
        d = instance.get(key, {})
        d['blessed_from'] = source_uuid
        instance[key] = d

    system_metadata = instance.get('system_metadata', {})
    if 'images' not in system_metadata:
        system_metadata['images'] = ''
    instance['system_metadata'] = system_metadata

    return create_instance(context, instance)

def create_pre_launched_instance(context, instance=None, source_uuid=None):

    if source_uuid == None:
        source_uuid = create_blessed_instance(context)
    if instance == None:
        instance = {}

    for key in ['metadata', 'system_metadata']:
        d = instance.get(key, {})
        d['launched_from'] = source_uuid
        instance[key] = d

    return create_instance(context, instance)

def create_launched_instance(context, instance=None, source_uuid=None):

    if instance == None:
        instance = {}

    instance['vm_state'] = vm_states.ACTIVE
    instance['host'] = "TEST_HOST"

    return create_pre_launched_instance(context, instance=instance, source_uuid=source_uuid)

def fake_networkinfo(*args, **kwargs):
    requested_networks = kwargs.get('requested_networks')
    networks = network_model.NetworkInfo()
    if requested_networks:
        for requested_network in requested_networks:
            networks.append(network_model.VIF(network=requested_network[0]))

    return networks

def create_cobalt_service(context):
    service = {'name': 'cobalt-test-service',
               'topic': 'cobalt',
               'host': create_uuid()
               }
    db.service_create(context, service)
    return service

def create_availability_zone(context, hosts):

    az = create_uuid()
    # Create a new host aggregate
    aggregate = db.aggregate_create(context, {'name': az}, metadata={'availability_zone': az})
    for host in hosts:
        db.aggregate_host_add(context, aggregate['id'], host)

    return az
